<!doctype html>
<!-- Based on Echo sample from Primus. -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ZombAttack</title>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/normalize/3.0.1/normalize.min.css">
  <script src="/primus/primus.js"></script>
  <script src="/scripts/hexi.min.js"></script>
  <script src="/scripts/game.js"></script>
  <style>
    body { padding: 5px }
  </style>
</head>
<body>  
  <script>
    // Track the latest world updates from the server's world update messages.
    // We start with an empty world until the server can get a first message
    // back to us.
    var currentWorld = createEmptyWorldUpdate();
    var scrollingTileCamera = null;
    var currentLevelName = null;
    var levelWorldObj = null;
    var numZombieGrowlSounds = 2;

    // Sound and graphics files we want to load via Hexi.js.
    var thingsToLoadIntoHexi = [
      // Sound files.

      "Sounds/CreepyBackgroundMusic.mp3",
      "Sounds/character1(girl)_hurt_0.mp3",
      "Sounds/character1(girl)_hurt_1.mp3",
      "Sounds/character2(boy)_hurt_0.mp3",
      "Sounds/character2(boy)_hurt_1.mp3",
      "Sounds/character3(boy)_hurt_0.mp3",
      "Sounds/character3(boy)_hurt_1.mp3",

      // CODESYNC: numZombieGrowlSounds above, and Zombie.js keeps this list as well.
      'Sounds/ZombieGrowl1.mp3',
      'Sounds/ZombieGrowl2.mp3',
      'Sounds/zombieHurt0.mp3',
      
      // Weapon sounds
      "Sounds/swoosh.mp3",
      "Sounds/miniGun.mp3",
      "Sounds/rifle.mp3",
      "Sounds/pistol.mp3",
      "Sounds/machinegun.mp3",
      "Sounds/chainsawawesome.mp3",

      // Spritesheet and tileset JSON metadata files and related PNGs.
      'images/ZombAttackSpritesheet.json',
      'images/ZombAttackTileset.png',

      // Game map definitions in Tiled Editor (http://mapeditor.org) comma-separated value (CSV) JSON
      // format, suitable for use with Hexi's GameUtilities.
      'Levels/SpawnCity.json',
      'Levels/theFarm.json',
    ];
    
    // Hexi.js (and Pixi.js) setup. Pixi will autodetect the browser's capabilities and
    // choose the fastest renderer (WebGL or HTML5 Canvas).
    var hexiObj = hexi(window.innerWidth, window.innerHeight, hexiSetupCompleted, thingsToLoadIntoHexi, hexiLoading);
    hexiObj.fps = 30;  // Game logic loop runs at this rate. Sprites still render at 60 fps.
    hexiObj.backgroundColor = 0x000000;  // black
    hexiObj.scaleToWindow();
    hexiObj.start();

    var zombieSounds = [];
    var characterInfo = [
      {
        costumeFrames: hexiObj.spriteUtilities.frameSeries(0, 1, "vplayer"),
        hurtSounds: [],
      },
      {
        costumeFrames: hexiObj.spriteUtilities.frameSeries(0, 1, "playerE0"),
        hurtSounds: [],
      },
      {
        costumeFrames: hexiObj.spriteUtilities.frameSeries(0, 1, "playerE1"),
        hurtSounds: [],
      },
    ];

    // User interface spites and tracking info.
    var playerHealthSprite = undefined;
    var playerWeaponSprite = undefined;
    var playerWeaponNumber = -1;
    var playerAmmoSprite = undefined;
    var playerDeathSprite = undefined;
    var playerDeathStart = 0;

    function hexiLoading() {
      hexiObj.loadingBar();
    }

    function hexiSetupCompleted() {
      console.log("Hexi setup complete");

      // CODESYNC: The number of sounds here is set in Zombie.js numGrowlSounds and in numZombieGrowlSounds above
      zombieSounds[0] = hexiObj.sound('Sounds/ZombieGrowl1.mp3');
      zombieSounds[1] = hexiObj.sound('Sounds/ZombieGrowl2.mp3');

      // CODESYNC: The number of sounds here is set in Zombie.js numHurtSounds
      zombieSounds[2] = hexiObj.sound('Sounds/zombieHurt0.mp3');
      
      // CODESYNC: The number of sounds here is set in RunNodeSiteServer.js numPlayerHurtSounds
      characterInfo[0].hurtSounds = [
        hexiObj.sound('Sounds/character1(girl)_hurt_0.mp3'),
        hexiObj.sound('Sounds/character1(girl)_hurt_1.mp3'),
      ]; 
      characterInfo[1].hurtSounds = [
        hexiObj.sound('Sounds/character2(boy)_hurt_0.mp3'),
        hexiObj.sound('Sounds/character2(boy)_hurt_1.mp3'),
      ];
      characterInfo[2].hurtSounds = [
        hexiObj.sound('Sounds/character3(boy)_hurt_0.mp3'),
        hexiObj.sound('Sounds/character3(boy)_hurt_1.mp3'),
      ];

      // CODESYNC: The number of sounds here is set in RunNodeSiteServer.js numPlayerHurtSounds
      logo1Setup();
    }

    var logo1Sprite = undefined;
    var logo1Start;
    function logo1Setup() {
      logo1Start = (new Date()).getTime();
      logo1Sprite = hexiObj.sprite("6KidsLogo");
      logo1Sprite.alpha = 0;
      logo1Sprite.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
      hexiObj.stage.putCenter(logo1Sprite);
      hexiObj.state = logo1Loop;
    }
    function logo1Loop() {
      var now = (new Date()).getTime();
      var dt = now - logo1Start;
      if (dt < 600) {
        logo1Sprite.alpha = (dt / 600) * (dt / 600);
      } else if (dt < 1200) {
        logo1Sprite.alpha = 1;
      } else if (dt < 1800) {
        logo1Sprite.alpha = (600 - (dt - 1200)) / 600;
      } else {
        hexiObj.remove(logo1Sprite);
        esrbLogoSetup();
      }
    }

    var esrbSprite = undefined;
    var esrbLogoStart;
    function esrbLogoSetup() {
      console.log("esrbLogoSetup");
      esrbLogoStart = (new Date()).getTime();
      esrbSprite = hexiObj.sprite("esrbRating");
      esrbSprite.alpha = 0;
      esrbSprite.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
      hexiObj.stage.putCenter(esrbSprite);
      hexiObj.state = esrbLogoLoop;
    }
    function esrbLogoLoop() {
      var now = (new Date()).getTime();
      var dt = now - esrbLogoStart;
      if (dt < 250) {
        esrbSprite.alpha = (dt / 250) * (dt / 250);
      } else if (dt < 750) {
        esrbSprite.alpha = 1;
      } else if (dt < 1000) {
        esrbSprite.alpha = (250 - (dt - 750)) / 250;
      } else {
        hexiObj.remove(esrbSprite);
        logo2Setup();
      }
    }


    var logo2Sprite = undefined;
    var logo2Start;
    function logo2Setup() {
      logo2Start = (new Date()).getTime();
      logo2Sprite = hexiObj.sprite("ZombAttackLogo1");
      logo2Sprite.alpha = 0;
      logo2Sprite.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
      hexiObj.stage.putCenter(logo2Sprite);
      hexiObj.state = logo2Loop;

      // Start creepy music at the start of the ZombAttack logo.
      var music = hexiObj.sound("Sounds/CreepyBackgroundMusic.mp3");
      music.loop = true;
      music.fadeIn(1);
      music.volume = 0.5;
      music.play();
    }
    function logo2Loop() {
      var now = (new Date()).getTime();
      var dt = now - logo2Start;
      if (dt < 600) {
        logo2Sprite.alpha = (dt / 600) * (dt / 600);
      } else if (dt < 1200) {
        logo2Sprite.alpha = 1;
      } else if (dt < 1800) {
        logo2Sprite.alpha = (600 - (dt - 1200)) / 600;
      } else {
        hexiObj.remove(logo2Sprite);
        gameLoopSetup();
      }
    }

    function gameLoopSetup() {
      playerHealthSprite = hexiObj.text("HEALTH: ", "24px sans-serif", "white", 10, 10);
      playerHealthSprite.alpha = 0.5;
      playerHealthSprite.layer = 1000;  // Foremost

      playerAmmoSprite = hexiObj.text("AMMO: ", "24px sans-serif", "white", 10, 88);
      playerAmmoSprite.alpha = 0.5;
      playerAmmoSprite.layer = 1000;  // Foremost
      playerAmmoSprite.visible = false;

      copyrightSprite = hexiObj.text("Copyright 2016 6KidsGames.com", "16px sans-serif", "white", 10, 625);
      copyrightSprite.alpha = 0.4;
      copyrightSprite.layer = 1000;

      hexiObj.state = gameLoop;
    }

    // Tell Primus to create a new WebSockets connection to the current domain/port/protocol.
    // Get the primus connection spark ID when we connect - we need it for knowing which player
    // we are in the world state passed from the server. 
    var primus = Primus.connect();
    var currentPrimusSparkID;
    primus.on("open", function () {
      console.log("Connected to server through Primus.");
      primus.id(function (id) {
        currentPrimusSparkID = id;
        console.log("Current Primus spark ID: " + id);
      });
    });

    function nameOrUnknown(name) {
      if (name) return name;
      return "Unknown";
    }
    
    // Listen for incoming messages from the server.
    primus.on('data', function received(data) {
      if (data.t === 0) {  // World update
        // console.log("Received world update:", data);
        currentWorld = data;
      }
      else {
        console.log("ERROR: Received unknown message type " + data.t)
      }
    });

    // Helpers that track the state of keyboard keys by hooking the current window's key events
    // and tracking if a key down or up has occurred.
    var keyPressed = [];
    window.onkeyup = function(keyEvent) { /*console.log("keyup: " + keyEvent.keyCode);*/ keyPressed[keyEvent.keyCode] = false; }
    window.onkeydown = function(keyEvent) { /*console.log("keydown: " + keyEvent.keyCode);*/ keyPressed[keyEvent.keyCode] = true; }

    // Key codes. Full table at http://www.cambiaresearch.com/articles/15/javascript-key-codes
    var KEY_W = 87;
    var KEY_S = 83;
    var KEY_A = 65;
    var KEY_D = 68;
    var KEY_SPACE = 32;
    var KEY_E = 69;
    var KEY_R = 82;
    var KEY_1 = 49;
    var KEY_2 = 50;
    var KEY_3 = 51;
    var KEY_4 = 52;
    var KEY_5 = 53;
    var KEY_6 = 54;
    var KEY_7 = 55;
    var KEY_8 = 56;
    var KEY_9 = 57;
    
    // Keep a copy of the last PlayerControlInfo message sent, so we don't send
    // a new message if there has been no change since the last one.
    var prevControlInfo = { };

    // Keep a copy of the last game world update we processed in gameLoop().
    // Each time through the loop, a new world update might have appeared
    // including new or removed players.
    var lastProcessedWorldUpdate = createEmptyWorldUpdate();

    // Keep a record of all players we know about right now. Each time
    // through gameLoop() the latest world update might include different
    // or new or removed players. This is also our record for keeping track
    // of all the things the game engine needs (e.g. sprites).
    var playerDatas = { };
    function forEachPlayerData(func) { forEachInMap(playerDatas, func); }

    // Keep a record of all un-picked-up weapons we know about right now. Each time
    // through gameLoop() the latest world update might include different
    // or new or removed weapons. This is also our record for keeping track
    // of all the things the game engine needs (e.g. sprites).
    var weaponDatas = { };
    function forEachWeaponData(func) { forEachInMap(weaponDatas, func); }

    // Keep a record of all zombies in play right now.
    var zombieDatas = { };
    function forEachZombieData(func) { forEachInMap(zombieDatas, func); }

    // Keep a record of all bullets in play right now.
    var bulletDatas = { };
    function forEachBulletData(func) { forEachInMap(bulletDatas, func); }

    // Keep track of the local player's weapon change ID - we increment this each time the player
    // actually presses a weapon key so the server knows that the controlInfo.w value was updated.
    var currentWeaponChangeID = 0;

    // Called 30 times per second by the Hexi main loop.
    function gameLoop() {
      var currentTime = (new Date()).getTime();

      // Create a new, empty PlayerControlInfo message to send to the server
      // with our current control status.
      var controlInfo = {
        t: 0,  // Control message type
        wC: currentWeaponChangeID,
      };

      // Create tile world object if we have never updated a level before, or if we changed levels.
      // Must come early in loop logic since we need to add and update sprites as children of the level object.
      if (currentLevelName !== currentWorld.l) {
        console.log(`Loading level ${currentWorld.l}`);
        currentLevelName = currentWorld.l;
        levelWorldObj = hexiObj.makeTiledWorld("Levels/" + currentWorld.l + ".json", 'images/ZombAttackTileset.png');
        levelWorldObj.layer = 0;  // Rearmost.
      }

      // Mark all players we are tracking as touched=false to detect removed players.
      // Make changes to player sprites from the current world state sent by the server.
      clearAllMapTouches(playerDatas);
      var myPlayerData  = null;
      var playerDatasToPlayWeaponSound = [];  // To allow playing after myPlayerData is determined
      var playersToPlayOuchSound = [];  // To allow playing after myPlayerData is determined
      for (var i = 0; i < currentWorld.p.length; i++) {
        var player = currentWorld.p[i];

        // Player might be new. If so, create a new sprite.
        var playerData = null;
        if (!playerDatas.hasOwnProperty(player.id)) {
          playerData = {
            id: player.id,
            lastSoundCount: player.sC,  // On reconnect, we don't want a ton of sounds, so use the current server count and play the next ones sent.
            lastWeaponUseCount: player.wC,
            sprite: createNewPlayerSprite(player.w),
            weapon: -1,
          };

          playerDatas[player.id] = playerData;
        }
        else {
          playerData = playerDatas[player.id];
        }
        playerData.touched = true;

        if (myPlayerData == null && player.id === currentPrimusSparkID) {
          myPlayerData = playerData;

          // It's hard to tell the current player amongst all the others.
          // Add a translucent circle centered on the local player. 
          if (!myPlayerData.markedForBetterViewing) {
            var highlightCircle = hexiObj.circle(diameter = 64);
            highlightCircle.alpha = 0.3;
            highlightCircle.anchor.x = 0.5;
            highlightCircle.anchor.y = 0.5;
            myPlayerData.sprite.addChild(highlightCircle);
            myPlayerData.markedForBetterViewing = true;
          }
        }

        // Update the sprite and playerData with current world information.
        playerData.sprite.x = player.x;
        playerData.sprite.y = player.y;
        playerData.sprite.rotation = player.d;
        playerData.lastHealth = playerData.health;
        playerData.lastAmmo = playerData.ammo;
        playerData.lastDead = playerData.dead;
        playerData.health = player.h;
        if (playerData.weapon !== player.w) {
          playerData.weapon = player.w;
          setPlayerWeaponSprite(playerData.sprite, player.w);
        }
        
        playerData.ammo = player.a;
        playerData.dead = player.dead;

        if (player.sC > playerData.lastSoundCount) {
          playerData.lastSoundCount = player.sC;
          playersToPlayOuchSound.push(player);

          // Create a blood spray using particles.
          hexiObj.createParticles(
            player.x, player.y,
            () => hexiObj.circle(8, "red"),
            levelWorldObj,
            10,  // Num particles
            0,  // Gravity
            false,  // randomSpacing
            0, 6.28,  // Min/max angle - allow whole circle
            8, 24,  // Min/max size
            1.2, 2.4,  // Min/max speed
            0.01, 0.03,  // Min/max scale speed
            0.05, 0.15,  // Min/max alpha speed
            0, 0);  // Min/max rotation speed
        }

        if (player.wC > playerData.lastWeaponUseCount) {
          playerData.lastWeaponUseCount = player.wC;

          console.log(`P${player.id} using W${playerData.weapon}`);

          // TODO: Animate melee weapons.

          playerDatasToPlayWeaponSound.push(playerData);
        }
      }

      if (myPlayerData.health !== myPlayerData.lastHealth) {
        playerHealthSprite.content = "HEALTH: " + myPlayerData.health;
      }

      if (myPlayerData.ammo !== myPlayerData.lastAmmo) {
        if (myPlayerData.ammo < 0) {
          playerAmmoSprite.visible = false;
        } else {
          playerAmmoSprite.content = "AMMO: " + myPlayerData.ammo;
          playerAmmoSprite.visible = true;
        }
      }

      if (myPlayerData.weapon !== playerWeaponNumber) {
        // console.log("Player weapon in UI changing from", playerWeaponNumber, "to", myPlayerData.weapon);
        createPlayerWeaponUISprite(myPlayerData.weapon);
        playerWeaponNumber = myPlayerData.weapon;
      }

      playersToPlayOuchSound.forEach(player => {
        playSound(characterInfo[player.n].hurtSounds[player.s], player, myPlayerData.sprite);
      });
      playerDatasToPlayWeaponSound.forEach(playerData => {
          // Play the sound related to the weapon.
          var weaponSound = WeaponNumberMap[playerData.weapon].attackSound;
          if (weaponSound) {
            playSound(hexiObj.sound(weaponSound), playerData.sprite, myPlayerData.sprite);
          }
      });

      if (myPlayerData.dead) {
        if (!myPlayerData.lastDead) {  // Just died
          playerDeathStart = currentTime;
 
          console.log("Player died! Starting fadeout");

          playerDeathSprite = hexiObj.rectangle(
            window.innerWidth,
            window.innerHeight,
            "black",  // <fillColor></fillColor>
            "black",  // lineColor
            0,  // lineWidth 
            0,  // xPosition 
            0);  // yPosition
          playerDeathSprite.alpha = 0;
          playerDeathSprite.layer = 5000;  // In front of all other sprites including user interface.

          var deathMessageSprite = hexiObj.text(
              "You died.\nRefresh to respawn.",
              "40px sans-serif",
              "white",
              0, 0);
          deathMessageSprite.layer = 10000;  // Above the fade-out.
          hexiObj.stage.putCenter(deathMessageSprite);
        } else {
          // Continue fade-out
          var timeSinceDeath = currentTime - playerDeathStart;
          if (timeSinceDeath < 3000) {
            console.log(`${timeSinceDeath} ms since death, still fading out`)
            playerDeathSprite.alpha = timeSinceDeath / 3000;
          } else {
            playerDeathSprite.alpha = 1;
          }
        }
      }

      // Find any playerDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachPlayerData(function(playerData) {
        if (!playerData.touched) {
          console.log(`Removing P${playerData.id} from the world`);
          playerData.sprite.visible = false;
          hexiObj.remove(playerData.sprite);
          playerDatas[playerData.id] = undefined;
        }
      });

      // Mark all weapons we are tracking as touched=false to detect removed weapons.
      // Make changes to weapon sprites from the current world state sent by the server.
      clearAllMapTouches(weaponDatas);
      for (var i = 0; i < currentWorld.w.length; i++) {
        var weapon = currentWorld.w[i];

        // Weapon might be new. If so, create a new sprite.
        var weaponData = null;
        if (!weaponDatas.hasOwnProperty(weapon.id)) {
          weaponData = {
            id: weapon.id,
            sprite: createNewWeaponSprite(weapon),
          };

          weaponDatas[weapon.id] = weaponData;
        }
        else {
          weaponData = weaponDatas[weapon.id];
        }
        weaponData.touched = true;
      }
    
      // Find any weaponDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachWeaponData(function(weaponData) {
        if (!weaponData.touched) {
          console.log("Removing W", weaponData.id, "from the world");
          weaponData.sprite.visible = false;
          hexiObj.remove(weaponData.sprite);
          weaponDatas[weaponData.id] = undefined;
        }
      });

      // Mark all bullets we are tracking as touched=false to detect removed ones.
      // Process bullet changes sent by the server.
      clearAllMapTouches(bulletDatas);
      for (var i = 0; i < currentWorld.b.length; i++) {
        var bullet = currentWorld.b[i];
        var bulletData = null;
        if (!bulletDatas.hasOwnProperty(bullet.id)) {
          // New bullet
          bulletData = {
            id: bullet.id,
            sprite: createNewBulletSprite(bullet),
            serverBulletInfo: bullet,
          };
          bulletDatas[bullet.id] = bulletData;
        }
        else {
          bulletData = bulletDatas[bullet.id];
        }
        bulletData.touched = true;

        // Update the sprite with current world information.
        bulletData.sprite.x = bullet.x;
        bulletData.sprite.y = bullet.y;
      }

      // Find any bulletDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachBulletData(function(bulletData) {
        if (!bulletData.touched) {
          bulletData.sprite.visible = false;
          hexiObj.remove(bulletData.sprite);
          bulletDatas[bulletData.id] = undefined;
        }
      });

      // Mark all zombies we are tracking as touched=false to detect removed zombies.
      // Process zombie changes sent by the server.
      clearAllMapTouches(zombieDatas);
      for (var i = 0; i < currentWorld.z.length; i++) {
        var zombie = currentWorld.z[i];

        // If new, create a new sprite.
        var zombieData = null;
        if (!zombieDatas.hasOwnProperty(zombie.id)) {
          zombieData = {
            id: zombie.id,
            sprite: createNewZombieSprite(zombie),
            serverZombieInfo: zombie,
            lastSoundCount: zombie.sC,  // On reconnect, we don't want a ton of sounds, so use the current server count and play the next ones sent.
            lastHealth: zombie.h,
          };
          zombieDatas[zombie.id] = zombieData;
        }
        else {
          zombieData = zombieDatas[zombie.id];
        }
        zombieData.touched = true;

        // See if the soundCount is newer than our last known update, and if so, start a sound.
        var zombieHurt = false;
        if (zombie.sC > zombieData.lastSoundCount) {
          zombieData.lastSoundCount = zombie.sC;
          //console.log(`Z${zombie.id} playing sound ${zombie.s}`);
          playSound(zombieSounds[zombie.s], zombie, myPlayerData.sprite);
          if (zombie.s >= numZombieGrowlSounds) {
            zombieHurt = true;
          }
        }

        var bloodParticles = 0;
        if (zombie.h <= 0) {
          if (!zombieData.dead) {
            zombieData.dead = true;
            console.log(`Z${zombie.id} dead`);
            bloodParticles = 20;
          }
        } else if (zombieHurt) {
          bloodParticles = 8; 
        }
        if (bloodParticles > 0) {
          // Create a blood spray using particles.
          hexiObj.createParticles(
            zombie.x, zombie.y,
            () => hexiObj.circle(8, "black"),
            levelWorldObj,
            bloodParticles,  // Num particles
            0,  // Gravity
            false,  // randomSpacing
            0, 6.28,  // Min/max angle - allow whole circle
            6, 16,  // Min/max size
            0.5, 4,  // Min/max speed
            0.01, 0.03,  // Min/max scale speed
            0.05, 0.14,  // Min/max alpha speed
            0, 0);  // Min/max rotation speed
        }
        
        // Update the sprite with current world information.
        zombieData.sprite.x = zombie.x;
        zombieData.sprite.y = zombie.y;
        zombieData.sprite.rotation = zombie.d;
      }

      // Find any zombieDatas that were not touched this round and remove -
      // they are gone from the world.
      forEachZombieData(function(zombieData) {
        if (!zombieData.touched) {
          console.log(`Removing Z${zombieData.id} from the world`);
          zombieData.sprite.visible = false;
          hexiObj.remove(zombieData.sprite);
          zombieDatas[zombieData.id] = undefined;
        }
      });

      if (scrollingTileCamera === null) {
        scrollingTileCamera = hexiObj.worldCamera(levelWorldObj, currentWorld.lW, currentWorld.lH);
        scrollingTileCamera.centerOver(myPlayerData.sprite);
      }

      // Control keys don't change anything locally, we send to the server and it
      // determines what happens.
      if (keyPressed[KEY_W]) { controlInfo.F = true; }  // Forward
      if (keyPressed[KEY_S]) { controlInfo.B = true; }  // Back
      if (keyPressed[KEY_A]) { controlInfo.L = true; }  // Left 
      if (keyPressed[KEY_D]) { controlInfo.R = true; }  // Right
      if (keyPressed[KEY_SPACE]) { controlInfo.A = true; }  // Attack
      for (var i = KEY_1; i <= KEY_9; i++) {
        if (keyPressed[i]) {
          //console.log("Weapon change key:", i - KEY_1);
          controlInfo.w = i - KEY_1;  // Weapon number 0-8
          currentWeaponChangeID++;
          controlInfo.wC = currentWeaponChangeID;
          break;
        }
      }

      // Send the control update to the game server if it's different from the last update.
      // TODO: This should be handled asynchronously instead of in the game
      // loop to avoid slowing down local animation.
      if (!objects_equal(controlInfo, prevControlInfo)) {
        primus.write(controlInfo);
        prevControlInfo = controlInfo;
      }

      // Keep the local player's sprite centered on the screen, and move the level map around the player.
      scrollingTileCamera.follow(myPlayerData.sprite);

      var processingTimeMsec = (new Date()).getTime() - currentTime;
      if (processingTimeMsec > 50) {
        console.log(`Excessive loop processing time: ${processingTimeMsec} ms`);
      }
    }

    function createPlayerWeaponUISprite(weaponNumber) {
      if (playerWeaponSprite) { hexiObj.remove(playerWeaponSprite); }
      playerWeaponSprite = hexiObj.sprite(WeaponNumberMap[weaponNumber].sprite, 10, 37);
      playerWeaponSprite.scale.x = 1.5;
      playerWeaponSprite.scale.y = 1.5;
      playerWeaponSprite.alpha = 0.4;
      playerWeaponSprite.layer = 1000;  // Foremost
    }

    function createNewPlayerSprite(weaponNumber) {
      var sprite = hexiObj.sprite(hexiObj.spriteUtilities.frameSeries(0, 1, "vplayer"), 0, 0);

      // Add to the tile world so its position remains relative to that world.
      levelWorldObj.addChild(sprite);

      sprite.fps = 2;
      sprite.playAnimation();
      sprite.anchor.x = 0.5;
      sprite.anchor.y = 0.5;
      sprite.layer = 100;  // In front of the tile map, weapons, zombies, but behind user interface

      var weapon = hexiObj.sprite(WeaponNumberMap[weaponNumber].playerHolding, 0, WeaponNumberMap[weaponNumber].yPos);
      weapon.anchor.x = 0.5;
      weapon.anchor.y = 0.5;
      weapon.layer = 101;
      sprite.addChild(weapon);
    

      return sprite;
    }
  
    function setPlayerWeaponSprite(playerSprite, weaponNumber) {
      playerSprite.children[0].texture = hexiObj.image(WeaponNumberMap[weaponNumber].playerHolding);
      playerSprite.children[0].y = WeaponNumberMap[weaponNumber].yPos;  
    }

    // Map from zombie costume numbers into texture names.
    // CODESYNC: Numeric keys are mapped in Zombie.js.
    var ZombieCostumeIDMap = {
      0: "crawler_",
      1: "vcrawlerzombie",
      2: "czombie_",
      3: "vnormalzombie",
    }; 

    function createNewBulletSprite(serverBulletInfo) {
      var sprite = hexiObj.sprite("bullet", serverBulletInfo.x, serverBulletInfo.y);

      // Add to the tile world so its position remains relative to that world.
      levelWorldObj.addChild(sprite);

      sprite.anchor.x = 0.5;
      sprite.anchor.y = 0.5;
      sprite.layer = 7;  // Behind player and zombies but in front of map tiles and weapons.

      return sprite;
    }

    function createNewZombieSprite(serverZombieInfo) {
      var costumeName = ZombieCostumeIDMap[serverZombieInfo.c];
      console.log("Creating Z" + serverZombieInfo.id + " with costume " + costumeName +
          " at (" + serverZombieInfo.x + "," + serverZombieInfo.y + ")");
      var sprite = hexiObj.sprite(hexiObj.spriteUtilities.frameSeries(0, 1, costumeName), serverZombieInfo.x, serverZombieInfo.y);

      // Add to the tile world so its position remains relative to that world.
      levelWorldObj.addChild(sprite);

      sprite.fps = 2;
      sprite.playAnimation();
      sprite.anchor.x = 0.5;
      sprite.anchor.y = 0.5;
      sprite.layer = 10;  // Behind player but in front of map tiles.

      return sprite;
    }

    // Map from weapon numbers into texture names and sounds.
    // CODESYNC: Numeric keys are mapped in Weapon.js.
    var WeaponNumberMap = {
      0: { sprite: "vdagger",     attackSound: "Sounds/swoosh.mp3", playerHolding: "playerdagger", yPos: -14 },
      1: { sprite: "vHalligan",   attackSound: "Sounds/swoosh.mp3", playerHolding: "PlayerHalliganTool", yPos: -14 },
      2: { sprite: "vsword",      attackSound: "Sounds/swoosh.mp3", playerHolding: "PlayerSword", yPos: -16 },
      3: { sprite: "vchainsaw",   attackSound: "Sounds/chainsawawesome.mp3", playerHolding: "PlayerChainsaw", yPos: -14 },
      4: { sprite: "vpistol",     attackSound: "Sounds/pistol.mp3", playerHolding: "PlayerPistol", yPos: -14},
      5: { sprite: "vrifle",      attackSound: "Sounds/rifle.mp3", playerHolding: "playerRifle", yPos: -14 }, 
      6: { sprite: "vmachinegun", attackSound: "Sounds/machinegun.mp3", playerHolding: "playerMachineGun", yPos: -14},
      7: { sprite: "vminigun",    attackSound: "Sounds/miniGun.mp3", playerHolding: "playerMiniGun", yPos: -14 },
    };

    function createNewWeaponSprite(serverWeaponInfo) {
      var costumeName = WeaponNumberMap[serverWeaponInfo.n].sprite;
      console.log("Creating W" + serverWeaponInfo.id + " with costume " + costumeName +
          " at (" + serverWeaponInfo.x + "," + serverWeaponInfo.y + ")");
      var sprite = hexiObj.sprite(costumeName, serverWeaponInfo.x, serverWeaponInfo.y);

      // Add to the tile world so its position remains relative to that world.
      levelWorldObj.addChild(sprite);

      sprite.layer = 5;  // Behind player and zombies but in front of map tiles.

      return sprite;
    }

    function createEmptyWorldUpdate() {
      return {
        p: [],
        z: [],
        w: [],
        b: [],
      };
    }

    function clearAllMapTouches(map) {
      forEachInMap(map, function(val) { val.touched = false; });
    }

    // Plays a sound with attenuation based on distance, and pan effect based on relative postion on screen.
    // Consider the following 4 quadrants:
    //
    // Up, left    |    Up, right
    //           player 
    // Down, left  |    Down, right
    //
    // Overall sound strength is based on an inverse-linear decay with a base constant
    // chosen empirically for best effect. (Real sound falls off as inverse square but
    // for gameplay we want to be able to hear zombies further out.)
    // Left/right pan strength is chosen as the cosine of the angle between the player
    // and the sound emitter: If the emitter is directly right, the pan is fully to the
    // right, same for direct left. Directly above or below is zero (center).
    // Other locations mix based on the cosine value.
    function playSound(soundObj, playerPos, soundPos) {
      var xDist = soundPos.x - playerPos.x;
      var yDist = soundPos.y - playerPos.y;
      var sqrDist = xDist * xDist + yDist * yDist;
      var dist = Math.sqrt(sqrDist);
      var volume;
      var distanceConstant = 256;  // Vol = 1 out to this pixel distance
      if (sqrDist !== 0) {
        volume = distanceConstant / dist;
        if (volume > 1) {
          volume = 1;
        } else if (volume < 0.01) {
          volume = 0.01;
        }
      } else {
        volume = 1;
      }

      // Pan can be from -1 to 1. We want cosine = adjacent / hypotenuse, where adjacent is xDist, hypotenuse calculated from adjacent and opposite (yDist).
      var pan;
      if (xDist !== 0) {
        pan = xDist / dist;
      } else {
        // Directly above or below player.
        pan = 0;
      }

      // If we are reusing the same sound buffer for multiple plays, restart it now to avoid the previous
      // play becoming suddenly attenuated partway through.
      console.log(`Playing sound with volume ${volume} and pan ${pan} for xDist ${xDist} yDist ${yDist}`);
      soundObj.restart();
      soundObj.volume = volume;
      soundObj.pan = pan;
    }

    function forEachInMap(map, func) {
      var ids = Object.keys(map);
      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        if (map.hasOwnProperty(id)) {
          var val = map[id]; 
          if (val) {
            func(val);
          }
        }
      }
    }

    // Modified from article below, augmented with array validation.
    // http://stackoverflow.com/questions/1068834/object-comparison-in-javascript#1144249
    function objects_equal(x, y) {
      if ( x === y ) return true;
        // if both x and y are null or undefined and exactly the same

      if ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false;
        // if they are not strictly equal, they both need to be Objects

      if ( x.constructor !== y.constructor ) return false;
        // they must have the exact same prototype chain, the closest we can do is
        // test there constructor.

      if (Array.isArray(x)) {
        if (!Array.isArray(y)) return false;
        if (x.length != y.length) return false;
        for (var i = 0; i < x.length; i++) {
          if (!objects_equal(x[i], y[i])) return false;
        }
      }

      for ( var p in x ) {
        if ( ! x.hasOwnProperty( p ) ) continue;
          // other properties were tested using x.constructor === y.constructor

        if ( ! y.hasOwnProperty( p ) ) return false;
          // allows to compare x[ p ] and y[ p ] when set to undefined

        var xprop = x[p];
        var yprop = y[p];

        if ( xprop === yprop ) continue;
          // if they have the same strict value or identity then they are equal

        if ( typeof(xprop) !== "object" ) return false;
          // Numbers, Strings, Functions, Booleans must be strictly equal

        if (!objects_equal(xprop, yprop)) return false;
          // Objects and Arrays must be tested recursively
      }

      for ( p in y ) {
        if ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) ) return false;
          // allows x[ p ] to be set to undefined
      }
      return true;
    }

    // Returns a random integer between min (included) and max (excluded)
    // Using Math.round() will give you a non-uniform distribution!
    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min)) + min;
    }
  </script>
</body>
</html>
